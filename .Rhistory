evaluate(sd, c(1.4, 3.6, 7.9, 8.8))
evaluate(sd(c(1.50,2.90,3.45,4,5,6.70,7,8.21,9,10.60,11,12,13,14,15)))
submit()
evaluate(sd)
submit()
evaluate(c(1.50,2.90,3.45,4,5,6.70,7,8.21,9,10.60,11,12,13,14,15))
evaluate <- function(func, dat){
func(dat)
}
evaluate(sd, c(1.4, 3.6, 7.9, 8.8))
submit()
evaluate(sd(c(1.4,3.6, 7.9, 8.8)))
evaluate <- function(func, dat){
function(dat)
}
evaluate <- function(func, dat){
func(dat)
}
evaluate <- sd(func, dat){
func(dat)
}
submit()
evaluate(function(x) {x + 1}, c(1, 2))
evaluate(sd(x) {x + 1}, c(c(1.4, 3.6, 7.9, 8.8)))
evaluate(sd(c(1.4, 3.6, 7.9, 8.8)))
evaluate <- function(sd, c(1.4, 3.6, 7.9, 8.8)){
sd(c(1.4, 3.6, 7.9, 8.8))
}
sd(c(1.4, 3.6, 7.9, 8.8))
info()
skip()
evaluate(function(x){x+1},6)
evaluate(function(x){x[1]}, c(8, 4, 0))
evaluate(function(x){x[-1]}, c(8, 4, 0))
paste()
?paste
paste("Programming", "is", "fun!")
submit()
# }
#
# The simon_says function works just like the paste function, except the
# begining of every string is prepended by the string "Simon says:"
#
# Telegrams used to be peppered with the words START and STOP in order to
# demarcate the beginning and end of sentences. Write a function below called
# telegram that formats sentences for telegrams.
# For example the expression `telegram("Good", "morning")` should evaluate to:
# "START Good morning STOP"
telegram(c("Hello", "world", ",", "how", "are", "we", "today", "?"))
telegram <- function(...){
}
# }
#
# The simon_says function works just like the paste function, except the
# begining of every string is prepended by the string "Simon says:"
#
# Telegrams used to be peppered with the words START and STOP in order to
# demarcate the beginning and end of sentences. Write a function below called
# telegram that formats sentences for telegrams.
# For example the expression `telegram("Good", "morning")` should evaluate to:
# "START Good morning STOP"
telegram(c("Hello", "world", ",", "how", "are", "we", "today", "?"))
telegram()
telegram(c(Hello, world, how, are, you,?))
telegram(c("Hello", "world", ",", "how", "are", "we", "today", "?"))
telegram(c("Hello", "world", ",", "how", "are", "we", "today", "?"))
[1] "START Hello STOP" "START world STOP" "START , STOP"     "START how STOP"
[5] "START are STOP"   "START we STOP"    "START today STOP" "START ? STOP"
telegram <- function(...){
paste("START", ..., "STOP")
}
telegram()
submit()
# }
#
# The simon_says function works just like the paste function, except the
# begining of every string is prepended by the string "Simon says:"
#
# Telegrams used to be peppered with the words START and STOP in order to
# demarcate the beginning and end of sentences. Write a function below called
# telegram that formats sentences for telegrams.
# For example the expression `telegram("Good", "morning")` should evaluate to:
# "START Good morning STOP"
telegram(c("Hello", "world", ",", "how", "are", "we", "today", "?"))
telegram("hello","world")
telegram()
submit()
telegram <- function(...){
}
telegram <- function(...){
paste("START",...,"STOP",sep = "")
}
telegram()
submit()
telegram <- function(...){
+     paste("START", ...,"STOP",sep = "")
+ }
skip()
telegram()
submit()
args<-list(...)
args<-list(1:20)
args()
args<-list["name","surname","address"]
place<-args[1]
adjective<-args[2]
noun<-args[3]
args
submit()
submit()
args<-list["name","surname","address"]
args<-list[...]
mad_libs <- function(...){
# Do your argument unpacking here!
args<-list(...)
place<-args[1]
adjective<-args[2]
noun<-args[3]
# Don't modify any code below this comment.
# Notice the variables you'll need to create in order for the code below to
# be functional!
paste("News from", place, "today where", adjective, "students took to the streets in protest of the new", noun, "being installed on campus.")
}
submit()
mad_libs <- function(...){
# Do your argument unpacking here!
args<-list(1:20)
place<-args[1]
adjective<-args[2]
noun<-args[3]
# Don't modify any code below this comment.
# Notice the variables you'll need to create in order for the code below to
# be functional!
paste("News from", place, "today where", adjective, "students took to the streets in protest of the new", noun, "being installed on campus.")
}
mad_libs()
submit()
mad_libs(place = "London", adjustive = "beautiful", noun = "dog")
submit()
list(place = "London", adjustive = "beautiful", noun = "dog")
list()
mad_libs(list())
submit()
mad_libs(place = London, adjustive = "beautiful", noun = "dog")
mad_libs(place = "London", adjustive = "beautiful", noun = "dog")
list(place = "London", adjustive = "beautiful", noun = "dog")
list()
mad_libs(place = "London", adjustive = "beautiful", noun = "dog")
mad_libs(place = "London", adjustive = "beautiful", noun = "dog")
[1] "News from London today where  students took to the streets in protest of the new dog being installed on campus."
mad_libs(place = "London", adjustive = "beautiful", noun = "dog") "News from London today where  students took to the streets in protest of the new dog being installed on campus."
submit()
list(place = "London", adjustive = "beautiful", noun = "dog")
mad_libs(place = London, adjustive = "beautiful", noun = "dog")
mad_libs(place = "London", adjustive = "beautiful", noun = "dog")
list(place = "London", adjustive = "beautiful", noun = "dog")
mad_libs(place = London, adjustive = "beautiful", noun = "dog")
mad_libs <- function(...){
# Do your argument unpacking here!
args<-list(1:20)
place<-args[1]
adjective<-args[2]
noun<-args[3]
# Don't modify any code below this comment.
# Notice the variables you'll need to create in order for the code below to
# be functional!
paste("News from", place, "today where", adjective, "students took to the streets in protest of the new", noun, "being installed on campus.")
}
mad_libs(place = London, adjustive = "beautiful", noun = "dog")
# Do your argument unpacking here!
args<-list(London)
mad_libs <- function(...){
# Do your argument unpacking here!
args<-list(place = "London", adjustive = "beautiful", noun = "dog")
place<-args[1]
adjective<-args[2]
noun<-args[3]
# Don't modify any code below this comment.
# Notice the variables you'll need to create in order for the code below to
# be functional!
paste("News from", place, "today where", adjective, "students took to the streets in protest of the new", noun, "being installed on campus.")
}
mad_libs(place = "London", adjustive = "beautiful", noun = "dog")
submit()
mad_libs <- function(...){
# Do your argument unpacking here!
args<-list(place = "London", adjustive = "beautiful", noun = "dog")
place<-args[1]
adjective<-args[2]
noun<-args[3]
# Don't modify any code below this comment.
# Notice the variables you'll need to create in order for the code below to
# be functional!
paste("News from", place, "today where", adjective, "students took to the streets in protest of the new", noun, "being installed on campus.")
}
skip()
mad_libs <- function(...){
# Do your argument unpacking here!
args <- list(...)
place <- args[["place"]]
adjective <- args[["adjective"]]
noun <- args[["noun"]]
# Don't modify any code below this comment.
# Notice the variables you'll need to create in order for the code below to
# be functional!
paste("News from", place, "today where", adjective, "students took to the streets in protest of the new", noun, "being installed on campus.")
}
submit()
"%p%" <- function(left, right){
paste(left, right)
}
submit()
"%p%" <- function("Good" %p% "job!"){"Good job!"}
"%p%" <- function("Good", %p%,"job!"){"Good job!"}
%p% <- function("Good", %p%,"job!"){"Good job!"}
# R, but it allows you to define a new syntax for your function. I would only
# recommend making your own binary operator if you plan on using it often!
#
# User-defined binary operators have the following syntax:
#      %[whatever]%
# where [whatever] represents any valid variable name.
#
# Let's say I wanted to define a binary operator that multiplied two numbers and
# then added one to the product. An implementation of that operator is below:
#
"%mult_add_one%" <- function(left, right){ # Notice the quotation marks!
left * right + 1
}
submit()
"I" %p% "love" %p% "R!"
"%p%" <- function(left, right){ # Remember to add arguments!
paste(left, right, sep = " ")
}
"I" %p% "love" %p% "R!"
submit()
"%p%" <- function(left, right){ Hello' %p% 'student!
paste(left, right, sep = " ")
}
%p% <- function(Hello' %p% 'student!){"Good job!"}
"%p%" <- function(left, right){ Hello' %p% 'student!
paste(left, right, sep = " ")
}
# R, but it allows you to define a new syntax for your function. I would only
# recommend making your own binary operator if you plan on using it often!
#
# User-defined binary operators have the following syntax:
#      %[whatever]%
# where [whatever] represents any valid variable name.
#
# Let's say I wanted to define a binary operator that multiplied two numbers and
# then added one to the product. An implementation of that operator is below:
#
"%mult_add_one%" <- function(left, right){ # Notice the quotation marks!
left * right + 1
}
%mult_add_one%
submit()
"%p%" <- function(left, right){ # Remember to add arguments!
paste(left, right, sep = " ")
}
"Good" %p% "job!"
submit()
"Hello" %p% "student!"
"Hello" %p% "student!"
paste(left, right, sep = " ")
paste(left, right, sep = " ")
%p% <- function(Hello, student!){paste(left, right, sep = " ")
}
%p% <- function(Hello, student!){paste(left, right, sep = " ")
}
%p% <- function(Hello, student!){paste(left, right, sep = " ")}
%p%<- function(Hello, student!){paste(left, right, sep = " ")}
# R, but it allows you to define a new syntax for your function. I would only
# recommend making your own binary operator if you plan on using it often!
#
# User-defined binary operators have the following syntax:
#      %[whatever]%
# where [whatever] represents any valid variable name.
#
# Let's say I wanted to define a binary operator that multiplied two numbers and
# then added one to the product. An implementation of that operator is below:
#
"%mult_add_one%" <- function(left, right){ # Notice the quotation marks!
left * right + 1
}
#
# I could then use this binary operator like `4 %mult_add_one% 5` which would
# evaluate to 21.
#
# Write your own binary operator below from absolute scratch! Your binary
# operator must be called %p% so that the expression:
#
"Hello" %p% "student!"
skip()
paste(left, right)
}
"%p%" <- function(left, right){ # Remember to add arguments!
paste(left, right)
}
# "%mult_add_one%" <- function(left, right){ # Notice the quotation marks!
#   left * right + 1
# }
#
# I could then use this binary operator like `4 %mult_add_one% 5` which would
# evaluate to 21.
#
# Write your own binary operator below from absolute scratch! Your binary
# operator must be called %p% so that the expression:
#
"Good" %p% "job!"
"Good" %p% "job!"
"%p%" <- function(left, right){ # Remember to add arguments!
paste(left, right, sep = " ")
}
"%p%" <- function(left, right){
paste(left, right, sep = " ")
}
"%p%"<- function(left, right){
+     paste(left, right, sep = " ")
+ }
"%p%" <- function(left, right){ # Remember to add arguments!
paste(left, right, sep = " ")
}
"%p%" <- function(left, right){ # Remember to add arguments!
paste(left, right)
}
# "%mult_add_one%" <- function(left, right){ # Notice the quotation marks!
#   left * right + 1
# }
#
# I could then use this binary operator like `4 %mult_add_one% 5` which would
# evaluate to 21.
#
# Write your own binary operator below from absolute scratch! Your binary
# operator must be called %p% so that the expression:
#
"Good" %p% "job!"
# "%mult_add_one%" <- function(left, right){ # Notice the quotation marks!
#   left * right + 1
# }
#
# I could then use this binary operator like `4 %mult_add_one% 5` which would
# evaluate to 21.
#
# Write your own binary operator below from absolute scratch! Your binary
# operator must be called %p% so that the expression:
#
"Good" %p% "job!"
# "%mult_add_one%" <- function(left, right){ # Notice the quotation marks!
#   left * right + 1
# }
#
# I could then use this binary operator like `4 %mult_add_one% 5` which would
# evaluate to 21.
#
# Write your own binary operator below from absolute scratch! Your binary
# operator must be called %p% so that the expression:
#
"Good"%p%"job!"
submit()
skip()
dirname()
getwd()
swirl()
install.packages("swirl")
install.packages("swirl")
swirl()
swirl::install_course()
install.packages("swirl", dependencies = TRUE)
install.packages("swirl", dependencies = TRUE)
library("swirl")
select_language()
swirl()
head(flags)
dim(flags)
class(flags)
cls_list<-lapply(flags, class)
cls_list
class(cls_list)
as.character(cls_list)
sapply(cls_list)
cls_list<-sapply(flags, class)
cls_vect<-sapply(flags, class)
class(cls_vect)
sum(flags$orange)
flag_colors<-flags[,11:17]
head(flag_colors)
lapply(flag_colors, sum)
sapply(flag_colors,sum)
sapply(flag_colors,mean)
flag_shapes<-flags[,19:23]
lapply(flag_shapes,range)
shape_mat<-sapply(flag_shapes,range)
shape_mat
class(shape_mat)
unique(c(3,4,5,5,5,6,6))
unique_vals<-lapply(flags, unique)
unique_vals
length(unique_vals)
sapply(unique_vals, length)
sapply(flags,unique)
lapply(unique_vals,function(elem) elem[2])
sapply(flags, unique)
vapply(flags, unique, numeric(1))
ok()
sapply(flags,class)
vapply(flags,class,character(1))
?tapply
table(flags$landmass)
table(flags$animate)
tapply(flags$animate,flags$landmass,mean)
tapply(flags$population,flags$red,summary)
tapply(flags$landmass,flags$red,summary)
tapply(flags$population,flags$landmass,summary)
setwd("C:/Users/karda/Desktop/GEO/GeoestadÃ­stica/John Hopkins University - R/ProgrammingAssignment2")
install.packages(MASS)
MASS::abbey
library(MASS)
makeCacheMatrix <- function(x = matrix()) {
k <- NULL
set <- function(y){
x <<- y
k <<- NULL
}
get <- function()x
setInverse <- function(inverse) k <<- inverse
getInverse <- function() k
list(set = set, get = get,
setInverse = setInverse,
getInverse = getInverse)
}
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
k <- x$getInverse()
if(!is.null(k)){
message("getting cached data")
return(k)
}
mat <- x$get()
k <- solve(mat,...)
x$setInverse(k)
k
}
makeCacheMatrix()
f<-makeCacheMatrix(matrix(1:8,2,4))
f
makeCacheMatrix <- function(x = matrix(1:8,2,4)) {
k <- NULL
set <- function(y){
x <<- y
k <<- NULL
}
get <- function()x
setInverse <- function(inverse) k <<- inverse
getInverse <- function() k
list(set = set, get = get,
setInverse = setInverse,
getInverse = getInverse)
}
makeCacheMatrix()
makeCacheMatrix <- function(x = matrix(1:8,2,4)) {
k <- NULL
set <- function(y){
x <<- y
k <<- NULL
}
get <- function()x
setInverse <- function(inverse) k <<- inverse
getInverse <- function() k
list(set = set, get = get,
setInverse = setInverse,
getInverse = getInverse)
}
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
k <- x$getInverse()
if(!is.null(k)){
message("getting cached data")
return(k)
}
mat <- x$get()
k <- solve(mat,...)
x$setInverse(k)
k
}
makeCacheMatrix()
makeCacheMatrix(npk)
makeCacheMatrix <- function(x = matrix()) {
j <- NULL
set <- function(y){
x <<- y
j <<- NULL
}
get <- function()x
setInverse <- function(inverse) j <<- inverse
getInverse <- function() j
list(set = set, get = get,
setInverse = setInverse,
getInverse = getInverse)
}
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
j <- x$getInverse()
if(!is.null(j)){
message("getting cached data")
return(j)
}
mat <- x$get()
j <- solve(mat,...)
x$setInverse(j)
j
}
